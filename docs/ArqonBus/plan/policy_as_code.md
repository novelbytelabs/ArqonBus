# ArqonBus Policy-as-Code Initiative

**Strategy & Implementation Plan**

**Version:** 1.0.0
**Status:** Draft → Ratify into Constitution when ready
**Owner:** Architecture / Platform Engineering

---

## 0. Executive Summary

ArqonBus is governed by a strict Engineering Constitution and SOTA Engineering Doctrine. Today, those rules live primarily in documents and human reviewers’ heads. The **Policy-as-Code Initiative** makes those rules **executable**.

We will:

* Encode our architectural, protocol, security, testing, observability, and technical-debt rules as **machine-readable policies** (Rego).
* Enforce them using **Conftest** in CI and **Sentinel** (our CI Guardian Bot) for rich PR feedback.
* Gradually extend these policies from build-time enforcement to **runtime** (via our Wasm-based Overseer).

This document defines the **objectives, scope, design, and phased plan** to achieve that.

---

## 1. Objectives

The Policy-as-Code initiative has these core objectives:

1. **Prevent architectural drift**

   * Automatically detect violations of the Voltron pattern and layering rules.

2. **Enforce the Constitution & Doctrine automatically**

   * Turn written rules into executable checks that run on *every PR* and *every build*.

3. **Strengthen protocol & state machine correctness**

   * Ensure Protobuf, state machines, and specs stay in sync and evolve safely.

4. **Protect multi-tenancy & security boundaries**

   * Prevent cross-tenant leakage and unsafe patterns by construction.

5. **Reduce reviewer load and increase consistency**

   * Let machines handle mechanical checks; humans focus on design & tradeoffs.

6. **Make technical debt explicit, time-bounded, and enforced**

   * Disallow hidden, undocumented, or expired technical debt.

7. **Improve observability & test discipline**

   * Require metrics/logs/traces and tests for new behaviors.

In short: **every commit must uphold the ArqonBus Constitution by default.**

---

## 2. Scope

### 2.1 In-Scope (Phase 1)

We will focus Phase 1 on **high-leverage, low-ambiguity** policies:

* **Architecture rules** (Voltron layering, async boundaries)
* **Protocol evolution rules** (Protobuf safety)
* **State machine synchronization rules**
* **Testing rules** (unit, integration, coverage basics)
* **Security & tenant isolation rules**
* **Observability rules** (metrics/logs/traces baseline)
* **Technical debt rules** (TODO discipline, TTLs, TD IDs)

### 2.2 Out-of-Scope (for now)

These are important but will come later:

* Runtime OPA/OPA-Wasm policies in the Overseer
* K8s/Terraform policy enforcement (infra-as-code)
* Full chaos/perf rule integration (beyond what ACES already does)
* Tenant-customizable policies (per-tenant runtime rules)

---

## 3. Why Policy-as-Code (Rationale)

ArqonBus has **strong, non-negotiable rules** about:

* Layering (Shield / Spine / Brain / Storage)
* Protocol evolution
* Multi-tenancy
* Resilience
* Security & Zero Trust
* Code quality & testing
* Technical debt

Relying solely on human reviewers to enforce all of this is:

* Error-prone
* Inconsistent
* Difficult to scale with new engineers
* Hard to audit

**Policy-as-code** changes this by:

* Encoding rules as **code** (Rego policies)
* Running them consistently in CI/CD
* Providing deterministic pass/fail results
* Version-controlling policies alongside code
* Allowing rules to evolve with the system

This gives ArqonBus a **self-enforcing architecture**: the system itself refuses to accept changes that violate its own laws.

---

## 4. Chosen Technology: Conftest + Rego

We will use:

* **Rego** as the policy language
* **Conftest** as the CLI runner for policies in CI and local dev

Reasons:

* Works on arbitrary files: source code, JSON, YAML, Protobuf AST output, etc.
* Runs locally and in CI — no separate server needed.
* Fits smoothly inside GitHub Actions / Buildkite / GitLab CI.
* Aligns nicely with Sentinel, which can call Conftest and interpret violations into human-friendly comments.

OPA itself (server) remains an option for **runtime** policies later (e.g., Overseer), but **Conftest is the right tool for CI/build-time enforcement**.

---

## 5. Policy Categories (Phase 1)

These are the initial domains we will cover with policies.

### 5.1 Architecture Policies (Voltron Guard)

**Goal:** Enforce the Voltron pattern and prevent cross-layer violations.

Examples:

* Shield may not import DB/storage modules.
* Brain may not talk to sockets directly.
* Internal services may not use direct HTTP/RPC for internal communication (must go via the Spine).
* Async boundaries: certain modules may not call blocking APIs.

Inputs:

* File paths (`shield/`, `spine/`, `brain/`, `storage/`, etc.)
* Import graphs (generated by language-specific tools)
* Configuration files

Output: `deny[]` messages when architectural rules are broken.

---

### 5.2 Protocol Policies

**Goal:** Ensure safe, backward-compatible evolution of Protobuf definitions.

Examples:

* New fields must be optional, not required.
* Breaking changes require explicit approval & labeling.
* Deprecated fields must be properly annotated and cleaned up on schedule.
* `.proto` changes require an associated spec and tests.

Inputs:

* Parsed Protobuf descriptors (e.g., JSON dump)
* Git diff of `.proto` files
* `sentinel_rules.yml` or `data/` for allowed patterns

Output: `deny[]` on unsafe changes, `warn[]` for upcoming cleanups.

---

### 5.3 State Machine Synchronization Policies

**Goal:** Keep state machines, invariants, and code in sync.

Examples:

* Changes in state-handling modules require a corresponding update in `/state_machines`.
* New states/transitions must be documented.
* Invariants must be listed in both spec and SM docs.

Inputs:

* Git diff of `state_machines/`
* Git diff of relevant code modules
* Spec docs

Output: `deny[]` if related code changed but SM doc didn’t.

---

### 5.4 Testing Policies

**Goal:** Ensure new behaviors are properly tested.

Examples:

* New logic in core modules must have unit tests.
* Cross-service changes require integration tests.
* No `sleep()`-based timing in async tests.
* No significant coverage regression.

Inputs:

* Test files
* Coverage reports (JSON)
* Search for `sleep(` / `Process.sleep` in test directories

Output: `deny[]` for missing tests or coverage drops, `warn[]` for suspicious patterns.

---

### 5.5 Security & Multi-Tenancy Policies

**Goal:** Protect the bulkhead (tenant isolation) and ensure secure defaults.

Examples:

* NATS subjects, Valkey keys, etc. must include `TenantID`.
* No cross-tenant wildcards.
* No obvious secrets in code.
* Safety/Overseer logic must fail closed, not open.

Inputs:

* Code patterns for key/subject creation
* Secret scanners’ outputs
* Spec/labels for security-sensitive changes

Output: `deny[]` on missing tenant prefixes or secret-like patterns.

---

### 5.6 Observability Policies

**Goal:** Enforce Observability-First Development (OFD).

Examples:

* New public or tenant-facing endpoints must emit metrics.
* Logs must be structured (JSON or key-value), not ad-hoc strings.
* Traces/spans must cover new hot paths.
* Correlation IDs must propagate.

Inputs:

* Code for handlers/endpoints
* Metrics/log calls
* Trace/log patterns

Output: `deny[]` if new behavior lacks observability; `warn[]` for incomplete coverage.

---

### 5.7 Technical Debt Policies

**Goal:** Keep debt intentional, visible, and time-bounded.

Examples:

* All TODO/FIXME/HACK must reference a `TD-xxx` or issue ID.
* Every TD item must have severity + owner + TTL.
* Expired TTL must block merges.
* No new untracked debt in core layers.

Inputs:

* Comments in code
* `/technical_debt/**/*.md`
* Issue tracker (optional integration or exported data)

Output: `deny[]` when untracked or expired debt is found.

---

## 6. Policy Folder Structure

We will maintain a dedicated Policy-as-Code folder. Suggested layout:

```text
policy-as-code/
  README.md              # This document or a shortened version
  conftest.yml           # Config: where to find policies and which files to scan
  policies/
    architecture/
      layering.rego
      blocking_async.rego
    protocol/
      protobuf_evolution.rego
      deprecation.rego
    statemachines/
      sm_sync.rego
    testing/
      unit_required.rego
      integration_required.rego
      async_sleep.rego
    security/
      tenant_prefix.rego
      secrets.rego
    observability/
      metrics_required.rego
      logs_structured.rego
      traces_required.rego
    technical_debt/
      todo_ticket.rego
      ttl_enforced.rego
  data/
    layering_graph.json         # optional: module relationships
    allowed_patterns.json       # allowlists, exemptions
    baseline_coverage.json      # for coverage policy
    baseline_benchmarks.json    # optionally reused by ACES
```

This repo (or folder in main repo) becomes the **single source of truth** for policies.

---

## 7. Minimal Example Rules (Illustrative Only)

These are not final code, just to illustrate how rules look.

### 7.1 Architecture: Shield cannot import Storage

```rego
package arqonbus.architecture.layering

deny[msg] {
  some import
  input.package == "shield"
  import := input.imports[_]
  import.pkg == "storage"
  msg := sprintf("Shield layer cannot import storage module: %v", [import.pkg])
}
```

### 7.2 Technical Debt: TODO must reference TD-ID

```rego
package arqonbus.technical_debt.todo_ticket

deny[msg] {
  todo := input.todos[_]
  contains(todo.text, "TODO")
  not contains(todo.text, "TD-")
  msg := sprintf("TODO missing technical debt ID at %v:%v", [todo.file, todo.line])
}
```

### 7.3 Protocol: New Protobuf fields must be optional

```rego
package arqonbus.protocol.protobuf_evolution

deny[msg] {
  field := input.proto.fields[_]
  field.new == true
  field.label == "required"
  msg := sprintf("New Protobuf field '%v' must not be required.", [field.name])
}
```

These policies are evaluated by **Conftest**, which passes in the relevant `input` (json describing code, imports, todos, proto descriptors, etc.).

---

## 8. Integration With CI/CD (ACES)

We integrate policy-as-code into the ACES CI pipeline as a dedicated stage:

**Example GitHub Actions step:**

```yaml
- name: Run Policy-as-Code Checks (Conftest)
  uses: instrumenta/conftest-action@v1
  with:
    files: |
      shield/
      spine/
      brain/
      storage/
      proto/
      technical_debt/
    policy: policy-as-code/policies/
```

If any Rego rule produces `deny[]`, the step fails → ACES pipeline fails → PR cannot be merged.

Sentinel (the CI Guardian Bot) also uses the *same* policies:

* Calls `conftest test` or Rego library directly
* Reads violations
* Translates them into human-friendly PR comments & labels

Thus:

* **Conftest** = mechanical check & CI gate
* **Sentinel** = human-readable guidance and enforcement persona

---

## 9. Implementation Phases (Roadmap)

### Phase 1 — Foundation (2–3 weeks)

**Goals:**

* Set up `policy-as-code/` structure
* Implement ~10–15 high-value policies:

  * Architecture (layering)
  * Protocol additive rule
  * TODO/TD-ID discipline
  * Tenant prefix rule
  * Basic observability presence rule
* Integrate Conftest into CI (non-blocking initially)
* Add local `make policy-check` target

**Exit Criteria:**

* Policies run on every PR
* Developers can run them locally
* Violations visible as warnings in CI

---

### Phase 2 — Enforcement (3–6 weeks)

**Goals:**

* Expand policy coverage:

  * State machine synchronization
  * Testing requirements
  * Observability coverage
  * Secrets & security rules
* Tighten severity:

  * Turn key rules to **blocking** (deny)
* Integrate Sentinel:

  * Reads Conftest output
  * Posts structured feedback to PRs
  * Applies `sentinel-block` label for hard violations

**Exit Criteria:**

* Core rules (arch, protocol, security, TD) are blocking
* Sentinel is in active use on all PRs
* Documentation for “How to fix violations” exists

---

### Phase 3 — Runtime & Advanced Policies (Longer-Term)

**Goals:**

* Explore OPA → Wasm → Overseer integration:

  * Reuse some policies at runtime for enforcement
* Add performance/latency-based policies tied to SLOs
* Integrate chaos/incident learnings into policies

**Exit Criteria:**

* Some policies run not only at build-time, but also at runtime
* Policies are part of the broader governance loop (incidents → new policies)

---

## 10. Developer Workflow

**Local preflight check:**

```bash
# From project root
conftest test -p policy-as-code/policies .
```

**Typical dev loop:**

1. Make changes.
2. Run tests (`cargo test`, `mix test`).
3. Run policy checks (`conftest test ...`).
4. Fix violations.
5. Open PR.
6. Sentinel & ACES run full suite; policy checks run again in CI.

Violations are seen early locally, not only in CI.

---

## 11. How Sentinel, Conftest, and ACES Work Together

Think of your enforcement system as a **three-part guardian**:

### 1. **Conftest (Policy Engine)**

* Runs Rego policies over your code, configs, proto descriptors, etc.
* Emits hard, deterministic “allow/deny” decisions.
* Integrated into CI (ACES) and local dev.
* Purely mechanical and rule-based.

### 2. **Sentinel Bot (CI Guardian)**

* Sits on top of Conftest (and other tooling).
* Interprets violations and translates them into:

  * Human-readable PR comments
  * Labels like `sentinel-block`, `needs-spec`, `needs-tests`
* Enforces “soft” process rules:

  * Checks PR template completion
  * Matches spec to code changes
  * Nudges around design, not just mechanics
* Think: **the voice of the Constitution** in code review.

### 3. **ACES CI/CD Pipeline**

* Orchestrates all checks: build, tests, security, perf, chaos, policy-as-code, etc.
* Conftest is one stage; other tools feed into Sentinel as well.
* If Conftest or any other critical stage fails → ACES blocks merge.
* ACES is the **execution layer** of enforcement.

**Together:**

* **Conftest** encodes the **rules**.
* **Sentinel** explains and surfaces the rules at PR time.
* **ACES** ensures nothing ships unless rules + tests + perf + security all pass.

Result: a **self-governing engineering system** where:

* Laws are written as policies.
* Bots and pipelines enforce them.
* Humans focus on design, tradeoffs, and vision.
